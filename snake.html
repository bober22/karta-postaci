<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Snake – sterowanie SWIPE + wibracje i dźwięk</title>
<style>
  :root {
    --bg: #0b0f14;
    --panel: #121821;
    --text: #e7f0ff;
    --muted: #93a1b3;
    --accent: #4f9cff;
    --good: #7ae582;
    --bad: #ff6b6b;
  }
  * { box-sizing: border-box; }
  html, body {
    margin: 0; height: 100%;
    background: radial-gradient(1200px 800px at 40% -10%, #142032 0%, var(--bg) 60%);
    color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    overflow: hidden; /* nic nie przewija strony podczas gry */
  }
  .wrap {
    height: 100%;
    display: grid;
    grid-template-rows: auto 1fr auto;
    gap: 10px;
    padding: 12px clamp(10px, 3vw, 24px);
    touch-action: none; /* ważne na mobilkach – blokuje scroll/zoom gestami */
  }
  header, footer, .panel {
    background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,0));
    border: 1px solid rgba(255,255,255,.08);
    border-radius: 14px;
    backdrop-filter: blur(6px);
    padding: 10px 12px;
  }
  header {
    display: grid;
    grid-template-columns: 1fr auto auto;
    align-items: center;
    gap: 10px;
  }
  header .score { font-weight: 700; letter-spacing: .4px; }
  header .controls { display: flex; gap: 10px; align-items: center; }
  label.toggle {
    display: inline-flex; align-items: center; gap: 8px;
    padding: 6px 10px; border-radius: 10px; cursor: pointer;
    background: rgba(255,255,255,.06);
    border: 1px solid rgba(255,255,255,.08);
    user-select: none;
  }
  label.toggle input { accent-color: var(--accent); transform: translateY(1px); }
  .panel {
    display: grid; place-items: center;
  }
  canvas {
    width: min(92vw, 520px);
    height: min(92vw, 520px);
    max-width: 92vmin;
    max-height: 92vmin;
    background: #0d131b;
    border-radius: 16px;
    box-shadow: 0 10px 30px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.06);
    image-rendering: pixelated;
    touch-action: none; /* krytyczne – żeby palec nie przewijał strony */
  }
  .btn {
    appearance: none;
    border: 1px solid rgba(255,255,255,.14);
    background: linear-gradient(180deg, #1a2432, #121a26);
    color: var(--text);
    padding: 10px 14px; border-radius: 12px;
    font-weight: 600;
    cursor: pointer;
    transition: transform .05s ease, filter .2s ease, background .2s ease;
  }
  .btn:hover { filter: brightness(1.08); }
  .btn:active { transform: translateY(1px); }
  .btn.accent { border-color: rgba(79,156,255,.6); box-shadow: 0 0 0 3px rgba(79,156,255,.16) inset; }
  .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
  .hint { color: var(--muted); font-size: .92rem; }
  footer { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; }
  .status {
    font-weight: 700; letter-spacing: .3px;
    padding: 6px 10px; border-radius: 10px;
  }
  .status.ok { color: var(--good); background: rgba(122,229,130,.12); border: 1px solid rgba(122,229,130,.32); }
  .status.err { color: var(--bad); background: rgba(255,107,107,.12); border: 1px solid rgba(255,107,107,.32); }

  @media (min-width: 920px) {
    canvas { width: 520px; height: 520px; }
  }
</style>
</head>
<body>
<div class="wrap" id="wrap">
  <header>
    <div class="score">Wynik: <span id="score">0</span></div>
    <div class="controls">
      <label class="toggle" title="Włącz/wyłącz dźwięk">
        <input type="checkbox" id="soundToggle" checked />
        Dźwięk
      </label>
      <label class="toggle" title="Włącz/wyłącz wibracje">
        <input type="checkbox" id="vibrationToggle" checked />
        Wibracje
      </label>
    </div>
    <div class="row">
      <button id="startBtn" class="btn accent">Start</button>
      <button id="restartBtn" class="btn" style="display:none">Restart</button>
    </div>
  </header>

  <div class="panel">
    <canvas id="game" width="400" height="400" aria-label="Plansza gry Snake"></canvas>
  </div>

  <footer>
    <div class="hint">Sterowanie: <strong>SWIPE</strong> (palcem) lub klawisze strzałek. Brak klikania.</div>
    <div id="status" class="status ok" aria-live="polite">Gotowy.</div>
  </footer>
</div>

<script>
(() => {
  // --- USTAWIENIA GRY ---
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const TILE = 20;                 // wielkość kafelka
  const GRID = canvas.width / TILE; // 20x20
  const SPEED_MS = 110;            // interwał ruchu
  const WRAP_BOUNDS = false;       // jeśli true – ściany zawijają

  // --- UI ---
  const scoreEl = document.getElementById('score');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const statusEl = document.getElementById('status');
  const soundToggle = document.getElementById('soundToggle');
  const vibrationToggle = document.getElementById('vibrationToggle');
  const wrap = document.getElementById('wrap');

  // --- AUDIO (Web Audio) ---
  let audioCtx = null;
  let audioEnabled = true;
  function ensureAudio() {
    if (audioCtx || !audioEnabled) return;
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    } catch {}
  }
  function beep({ freq=880, dur=0.08, type='sine', gain=0.06 } = {}) {
    if (!audioEnabled) return;
    if (!audioCtx) return;
    const t0 = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(gain, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    osc.connect(g).connect(audioCtx.destination);
    osc.start(t0);
    osc.stop(t0 + dur + 0.02);
  }

  // --- WIBRACJE ---
  let vibrationEnabled = true;
  function vibe(pattern=30) {
    if (!vibrationEnabled) return;
    if ('vibrate' in navigator) {
      navigator.vibrate(pattern);
    }
  }

  // --- STAN GRY ---
  let snake, dir, nextDir, food, timer, score, running, gameOver;
  function reset() {
    snake = [{x:10, y:10}];
    dir = {x:1, y:0};
    nextDir = {x:1, y:0};
    food = spawnFood(snake);
    score = 0;
    running = false;
    gameOver = false;
    scoreEl.textContent = score;
    draw();
    statusOK('Gotowy.');
    restartBtn.style.display = 'none';
  }

  function spawnFood(body) {
    while (true) {
      const f = { x: (Math.random()*GRID|0), y: (Math.random()*GRID|0) };
      if (!body.some(s => s.x===f.x && s.y===f.y)) return f;
    }
  }

  function start() {
    if (running) return;
    if (gameOver) reset();
    running = true;
    statusOK('Gramy!');
    clearInterval(timer);
    timer = setInterval(tick, SPEED_MS);
  }

  function end() {
    running = false;
    gameOver = true;
    clearInterval(timer);
    statusERR('Koniec gry! Wynik: ' + score);
    restartBtn.style.display = 'inline-block';
    // efekt przegranej
    vibe([80, 60, 120]);
    ensureAudio(); beep({freq:220, dur:.18, type:'square', gain:.05});
  }

  // --- LOGIKA ---
  function tick() {
    // przenieś kierunek ustawiony przez gracza
    dir = nextDir;

    // nowa głowa
    let head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
    if (WRAP_BOUNDS) {
      head.x = (head.x + GRID) % GRID;
      head.y = (head.y + GRID) % GRID;
    }

    // kolizja ze ścianą
    if (!WRAP_BOUNDS && (head.x < 0 || head.x >= GRID || head.y < 0 || head.y >= GRID)) {
      return end();
    }
    // kolizja z ciałem
    if (snake.some(s => s.x === head.x && s.y === head.y)) {
      return end();
    }

    snake.unshift(head);

    // jedzenie
    if (head.x === food.x && head.y === food.y) {
      score++;
      scoreEl.textContent = score;
      food = spawnFood(snake);
      // feedback: krótki beep + wibracja
      ensureAudio(); beep({freq:920, dur:.06, type:'triangle', gain: .06});
      vibe([15, 30, 15]);
    } else {
      snake.pop();
    }

    draw();
  }

  // --- RYSOWANIE ---
  function drawGrid() {
    ctx.clearRect(0,0,canvas.width, canvas.height);
    // delikatna siatka
    ctx.strokeStyle = 'rgba(255,255,255,.05)';
    ctx.lineWidth = 1;
    for (let i=1; i<GRID; i++) {
      ctx.beginPath();
      ctx.moveTo(i*TILE+.5, 0); ctx.lineTo(i*TILE+.5, canvas.height); ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, i*TILE+.5); ctx.lineTo(canvas.width, i*TILE+.5); ctx.stroke();
    }
  }

  function drawSnake() {
    for (let i=0; i<snake.length; i++) {
      const s = snake[i];
      const isHead = i === 0;
      ctx.fillStyle = isHead ? '#4f9cff' : '#7aa6ff';
      ctx.fillRect(s.x*TILE+2, s.y*TILE+2, TILE-4, TILE-4);
      if (isHead) {
        ctx.fillStyle = 'rgba(255,255,255,.7)';
        ctx.fillRect(s.x*TILE+7, s.y*TILE+6, 3, 3);
        ctx.fillRect(s.x*TILE+TILE-10, s.y*TILE+6, 3, 3);
      }
    }
  }

  function drawFood() {
    ctx.fillStyle = '#7ae582';
    ctx.beginPath();
    const cx = food.x*TILE + TILE/2;
    const cy = food.y*TILE + TILE/2;
    ctx.arc(cx, cy, TILE*0.35, 0, Math.PI*2);
    ctx.fill();
  }

  function draw() {
    drawGrid();
    drawFood();
    drawSnake();
  }

  // --- STEROWANIE: SWIPE (bez klikania) + klawisze ---
  let touchStart = null;
  const SWIPE_MIN = 20; // px
  function onTouchStart(e) {
    ensureAudio(); // inicjalizacja po pierwszym geście
    if (e.touches && e.touches.length > 1) return; // ignoruj multitoucha
    const t = e.touches ? e.touches[0] : e;
    touchStart = { x: t.clientX, y: t.clientY };
    e.preventDefault();
  }
  function onTouchMove(e) {
    // zapobiegaj przewijaniu podczas prowadzenia palcem
    e.preventDefault();
  }
  function onTouchEnd(e) {
    if (!touchStart) return;
    const t = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : (e.touches ? e.touches[0] : null);
    const endX = t ? t.clientX : (e.clientX ?? touchStart.x);
    const endY = t ? t.clientY : (e.clientY ?? touchStart.y);
    const dx = endX - touchStart.x;
    const dy = endY - touchStart.y;
    const ax = Math.abs(dx), ay = Math.abs(dy);
    touchStart = null;

    if (Math.max(ax, ay) < SWIPE_MIN) return; // za krótki ruch

    // Horyzontalny vs pionowy
    if (ax > ay) {
      // prawo/lewo
      if (dx > 0 && dir.x !== -1) nextDir = {x:1, y:0};
      else if (dx < 0 && dir.x !== 1) nextDir = {x:-1, y:0};
    } else {
      // dół/góra
      if (dy > 0 && dir.y !== -1) nextDir = {x:0, y:1};
      else if (dy < 0 && dir.y !== 1) nextDir = {x:0, y:-1};
    }
  }

  // Klawiatura (opcjonalnie – desktop)
  function onKey(e) {
    const k = e.key;
    if (k === 'ArrowRight' && dir.x !== -1) nextDir = {x:1, y:0};
    else if (k === 'ArrowLeft'  && dir.x !== 1) nextDir = {x:-1, y:0};
    else if (k === 'ArrowUp'    && dir.y !== 1) nextDir = {x:0, y:-1};
    else if (k === 'ArrowDown'  && dir.y !== -1) nextDir = {x:0, y:1};
    else if (k === ' ' || k === 'Enter') start();
  }

  // --- STATUS UI ---
  function statusOK(msg)  { statusEl.className = 'status ok';  statusEl.textContent = msg; }
  function statusERR(msg) { statusEl.className = 'status err'; statusEl.textContent = msg; }

  // --- ZDARZENIA UI ---
  startBtn.addEventListener('click', () => { ensureAudio(); start(); });
  restartBtn.addEventListener('click', () => { ensureAudio(); reset(); start(); });

  soundToggle.addEventListener('change', () => {
    audioEnabled = soundToggle.checked;
    if (audioEnabled) ensureAudio();
  });
  vibrationToggle.addEventListener('change', () => {
    vibrationEnabled = vibrationToggle.checked;
  });

  // Dotyk – używamy passive:false, żeby móc preventDefault na move
  const touchOpts = { passive: false };
  canvas.addEventListener('touchstart', onTouchStart, touchOpts);
  canvas.addEventListener('touchmove',  onTouchMove,  touchOpts);
  canvas.addEventListener('touchend',   onTouchEnd,   touchOpts);
  // Na wszelki wypadek blokujemy gesty również na wrapperze
  wrap.addEventListener('touchmove', (e)=>e.preventDefault(), touchOpts);

  // Mysz NIE steruje (żeby nie było przypadkowych klików),
  // ale zostawiamy możliwość złapania focusu klawiaturą.
  canvas.addEventListener('mousedown', (e)=> e.preventDefault());

  window.addEventListener('keydown', onKey);

  // Start stanu początkowego
  reset();

})();
</script>
</body>
</html>